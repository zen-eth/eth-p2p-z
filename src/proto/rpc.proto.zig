// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const RPCWire = struct {
    const SUBSCRIPTIONS_WIRE: gremlin.ProtoWireNumber = 1;
    const PUBLISH_WIRE: gremlin.ProtoWireNumber = 2;
    const CONTROL_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const RPC = struct {
    // nested structs
    const SubOptsWire = struct {
        const SUBSCRIBE_WIRE: gremlin.ProtoWireNumber = 1;
        const TOPICID_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const SubOpts = struct {
        // fields
        subscribe: bool = false,
        topicid: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const RPC.SubOpts) usize {
            var res: usize = 0;
            if (self.subscribe != false) {
                res += gremlin.sizes.sizeWireNumber(RPC.SubOptsWire.SUBSCRIBE_WIRE) + gremlin.sizes.sizeBool(self.subscribe);
            }
            if (self.topicid) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(RPC.SubOptsWire.TOPICID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const RPC.SubOpts, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const RPC.SubOpts, target: *gremlin.Writer) void {
            if (self.subscribe != false) {
                target.appendBool(RPC.SubOptsWire.SUBSCRIBE_WIRE, self.subscribe);
            }
            if (self.topicid) |v| {
                if (v.len > 0) {
                    target.appendBytes(RPC.SubOptsWire.TOPICID_WIRE, v);
                }
            }
        }
    };
    pub const SubOptsReader = struct {
        buf: gremlin.Reader,
        _subscribe: bool = false,
        _topicid: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!RPC.SubOptsReader {
            const buf = gremlin.Reader.init(src);
            var res = RPC.SubOptsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    RPC.SubOptsWire.SUBSCRIBE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._subscribe = result.value;
                    },
                    RPC.SubOptsWire.TOPICID_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._topicid = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSubscribe(self: *const RPC.SubOptsReader) bool {
            return self._subscribe;
        }
        pub inline fn getTopicid(self: *const RPC.SubOptsReader) []const u8 {
            return self._topicid orelse &[_]u8{};
        }
    };
    // fields
    subscriptions: ?[]const ?RPC.SubOpts = null,
    publish: ?[]const ?Message = null,
    control: ?ControlMessage = null,
    pub fn calcProtobufSize(self: *const RPC) usize {
        var res: usize = 0;
        if (self.subscriptions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RPCWire.SUBSCRIPTIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.publish) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RPCWire.PUBLISH_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RPCWire.CONTROL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const RPC, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RPC, target: *gremlin.Writer) void {
        if (self.subscriptions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RPCWire.SUBSCRIPTIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RPCWire.SUBSCRIPTIONS_WIRE, 0);
                }
            }
        }
        if (self.publish) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RPCWire.PUBLISH_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RPCWire.PUBLISH_WIRE, 0);
                }
            }
        }
        if (self.control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RPCWire.CONTROL_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const RPCReader = struct {
    buf: gremlin.Reader,
    _subscriptions_offset: ?usize = null,
    _subscriptions_last_offset: ?usize = null,
    _subscriptions_cnt: usize = 0,
    _publish_offset: ?usize = null,
    _publish_last_offset: ?usize = null,
    _publish_cnt: usize = 0,
    _control_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!RPCReader {
        const buf = gremlin.Reader.init(src);
        var res = RPCReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RPCWire.SUBSCRIPTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._subscriptions_offset == null) {
                        res._subscriptions_offset = offset - result.size;
                    }
                    res._subscriptions_last_offset = offset;
                    res._subscriptions_cnt += 1;
                },
                RPCWire.PUBLISH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._publish_offset == null) {
                        res._publish_offset = offset - result.size;
                    }
                    res._publish_last_offset = offset;
                    res._publish_cnt += 1;
                },
                RPCWire.CONTROL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._control_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn subscriptionsCount(self: *const RPCReader) usize {
        return self._subscriptions_cnt;
    }
    pub fn subscriptionsNext(self: *RPCReader) ?RPC.SubOptsReader {
        if (self._subscriptions_offset == null) return null;
        const current_offset = self._subscriptions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = RPC.SubOptsReader.init(result.value) catch return null;
        if (self._subscriptions_last_offset != null and current_offset >= self._subscriptions_last_offset.?) {
            self._subscriptions_offset = null;
            return msg;
        }
        if (self._subscriptions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._subscriptions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RPCWire.SUBSCRIPTIONS_WIRE) {
                self._subscriptions_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._subscriptions_offset = null;
        return msg;
    }
    pub fn publishCount(self: *const RPCReader) usize {
        return self._publish_cnt;
    }
    pub fn publishNext(self: *RPCReader) ?MessageReader {
        if (self._publish_offset == null) return null;
        const current_offset = self._publish_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = MessageReader.init(result.value) catch return null;
        if (self._publish_last_offset != null and current_offset >= self._publish_last_offset.?) {
            self._publish_offset = null;
            return msg;
        }
        if (self._publish_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._publish_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RPCWire.PUBLISH_WIRE) {
                self._publish_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._publish_offset = null;
        return msg;
    }
    pub fn getControl(self: *const RPCReader) gremlin.Error!ControlMessageReader {
        if (self._control_buf) |buf| {
            return try ControlMessageReader.init(buf);
        }
        return try ControlMessageReader.init(&[_]u8{});
    }
};
const MessageWire = struct {
    const FROM_WIRE: gremlin.ProtoWireNumber = 1;
    const DATA_WIRE: gremlin.ProtoWireNumber = 2;
    const SEQNO_WIRE: gremlin.ProtoWireNumber = 3;
    const TOPIC_WIRE: gremlin.ProtoWireNumber = 4;
    const SIGNATURE_WIRE: gremlin.ProtoWireNumber = 5;
    const KEY_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Message = struct {
    // fields
    from: ?[]const u8 = null,
    data: ?[]const u8 = null,
    seqno: ?[]const u8 = null,
    topic: ?[]const u8 = null,
    signature: ?[]const u8 = null,
    key: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const Message) usize {
        var res: usize = 0;
        if (self.from) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MessageWire.FROM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.data) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MessageWire.DATA_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.seqno) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MessageWire.SEQNO_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.topic) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MessageWire.TOPIC_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.signature) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MessageWire.SIGNATURE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.key) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MessageWire.KEY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const Message, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Message, target: *gremlin.Writer) void {
        if (self.from) |v| {
            if (v.len > 0) {
                target.appendBytes(MessageWire.FROM_WIRE, v);
            }
        }
        if (self.data) |v| {
            if (v.len > 0) {
                target.appendBytes(MessageWire.DATA_WIRE, v);
            }
        }
        if (self.seqno) |v| {
            if (v.len > 0) {
                target.appendBytes(MessageWire.SEQNO_WIRE, v);
            }
        }
        if (self.topic) |v| {
            if (v.len > 0) {
                target.appendBytes(MessageWire.TOPIC_WIRE, v);
            }
        }
        if (self.signature) |v| {
            if (v.len > 0) {
                target.appendBytes(MessageWire.SIGNATURE_WIRE, v);
            }
        }
        if (self.key) |v| {
            if (v.len > 0) {
                target.appendBytes(MessageWire.KEY_WIRE, v);
            }
        }
    }
};
pub const MessageReader = struct {
    buf: gremlin.Reader,
    _from: ?[]const u8 = null,
    _data: ?[]const u8 = null,
    _seqno: ?[]const u8 = null,
    _topic: ?[]const u8 = null,
    _signature: ?[]const u8 = null,
    _key: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!MessageReader {
        const buf = gremlin.Reader.init(src);
        var res = MessageReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MessageWire.FROM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                MessageWire.DATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._data = result.value;
                },
                MessageWire.SEQNO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._seqno = result.value;
                },
                MessageWire.TOPIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._topic = result.value;
                },
                MessageWire.SIGNATURE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._signature = result.value;
                },
                MessageWire.KEY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._key = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrom(self: *const MessageReader) []const u8 {
        return self._from orelse &[_]u8{};
    }
    pub inline fn getData(self: *const MessageReader) []const u8 {
        return self._data orelse &[_]u8{};
    }
    pub inline fn getSeqno(self: *const MessageReader) []const u8 {
        return self._seqno orelse &[_]u8{};
    }
    pub inline fn getTopic(self: *const MessageReader) []const u8 {
        return self._topic orelse &[_]u8{};
    }
    pub inline fn getSignature(self: *const MessageReader) []const u8 {
        return self._signature orelse &[_]u8{};
    }
    pub inline fn getKey(self: *const MessageReader) []const u8 {
        return self._key orelse &[_]u8{};
    }
};
const ControlMessageWire = struct {
    const IHAVE_WIRE: gremlin.ProtoWireNumber = 1;
    const IWANT_WIRE: gremlin.ProtoWireNumber = 2;
    const GRAFT_WIRE: gremlin.ProtoWireNumber = 3;
    const PRUNE_WIRE: gremlin.ProtoWireNumber = 4;
    const IDONTWANT_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const ControlMessage = struct {
    // fields
    ihave: ?[]const ?ControlIHave = null,
    iwant: ?[]const ?ControlIWant = null,
    graft: ?[]const ?ControlGraft = null,
    prune: ?[]const ?ControlPrune = null,
    idontwant: ?[]const ?ControlIDontWant = null,
    pub fn calcProtobufSize(self: *const ControlMessage) usize {
        var res: usize = 0;
        if (self.ihave) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlMessageWire.IHAVE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.iwant) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlMessageWire.IWANT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.graft) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlMessageWire.GRAFT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.prune) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlMessageWire.PRUNE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.idontwant) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlMessageWire.IDONTWANT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ControlMessage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ControlMessage, target: *gremlin.Writer) void {
        if (self.ihave) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ControlMessageWire.IHAVE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ControlMessageWire.IHAVE_WIRE, 0);
                }
            }
        }
        if (self.iwant) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ControlMessageWire.IWANT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ControlMessageWire.IWANT_WIRE, 0);
                }
            }
        }
        if (self.graft) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ControlMessageWire.GRAFT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ControlMessageWire.GRAFT_WIRE, 0);
                }
            }
        }
        if (self.prune) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ControlMessageWire.PRUNE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ControlMessageWire.PRUNE_WIRE, 0);
                }
            }
        }
        if (self.idontwant) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ControlMessageWire.IDONTWANT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ControlMessageWire.IDONTWANT_WIRE, 0);
                }
            }
        }
    }
};
pub const ControlMessageReader = struct {
    buf: gremlin.Reader,
    _ihave_offset: ?usize = null,
    _ihave_last_offset: ?usize = null,
    _ihave_cnt: usize = 0,
    _iwant_offset: ?usize = null,
    _iwant_last_offset: ?usize = null,
    _iwant_cnt: usize = 0,
    _graft_offset: ?usize = null,
    _graft_last_offset: ?usize = null,
    _graft_cnt: usize = 0,
    _prune_offset: ?usize = null,
    _prune_last_offset: ?usize = null,
    _prune_cnt: usize = 0,
    _idontwant_offset: ?usize = null,
    _idontwant_last_offset: ?usize = null,
    _idontwant_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ControlMessageReader {
        const buf = gremlin.Reader.init(src);
        var res = ControlMessageReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ControlMessageWire.IHAVE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ihave_offset == null) {
                        res._ihave_offset = offset - result.size;
                    }
                    res._ihave_last_offset = offset;
                    res._ihave_cnt += 1;
                },
                ControlMessageWire.IWANT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._iwant_offset == null) {
                        res._iwant_offset = offset - result.size;
                    }
                    res._iwant_last_offset = offset;
                    res._iwant_cnt += 1;
                },
                ControlMessageWire.GRAFT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._graft_offset == null) {
                        res._graft_offset = offset - result.size;
                    }
                    res._graft_last_offset = offset;
                    res._graft_cnt += 1;
                },
                ControlMessageWire.PRUNE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._prune_offset == null) {
                        res._prune_offset = offset - result.size;
                    }
                    res._prune_last_offset = offset;
                    res._prune_cnt += 1;
                },
                ControlMessageWire.IDONTWANT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._idontwant_offset == null) {
                        res._idontwant_offset = offset - result.size;
                    }
                    res._idontwant_last_offset = offset;
                    res._idontwant_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn ihaveCount(self: *const ControlMessageReader) usize {
        return self._ihave_cnt;
    }
    pub fn ihaveNext(self: *ControlMessageReader) ?ControlIHaveReader {
        if (self._ihave_offset == null) return null;
        const current_offset = self._ihave_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ControlIHaveReader.init(result.value) catch return null;
        if (self._ihave_last_offset != null and current_offset >= self._ihave_last_offset.?) {
            self._ihave_offset = null;
            return msg;
        }
        if (self._ihave_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ihave_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlMessageWire.IHAVE_WIRE) {
                self._ihave_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ihave_offset = null;
        return msg;
    }
    pub fn iwantCount(self: *const ControlMessageReader) usize {
        return self._iwant_cnt;
    }
    pub fn iwantNext(self: *ControlMessageReader) ?ControlIWantReader {
        if (self._iwant_offset == null) return null;
        const current_offset = self._iwant_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ControlIWantReader.init(result.value) catch return null;
        if (self._iwant_last_offset != null and current_offset >= self._iwant_last_offset.?) {
            self._iwant_offset = null;
            return msg;
        }
        if (self._iwant_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._iwant_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlMessageWire.IWANT_WIRE) {
                self._iwant_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._iwant_offset = null;
        return msg;
    }
    pub fn graftCount(self: *const ControlMessageReader) usize {
        return self._graft_cnt;
    }
    pub fn graftNext(self: *ControlMessageReader) ?ControlGraftReader {
        if (self._graft_offset == null) return null;
        const current_offset = self._graft_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ControlGraftReader.init(result.value) catch return null;
        if (self._graft_last_offset != null and current_offset >= self._graft_last_offset.?) {
            self._graft_offset = null;
            return msg;
        }
        if (self._graft_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._graft_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlMessageWire.GRAFT_WIRE) {
                self._graft_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._graft_offset = null;
        return msg;
    }
    pub fn pruneCount(self: *const ControlMessageReader) usize {
        return self._prune_cnt;
    }
    pub fn pruneNext(self: *ControlMessageReader) ?ControlPruneReader {
        if (self._prune_offset == null) return null;
        const current_offset = self._prune_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ControlPruneReader.init(result.value) catch return null;
        if (self._prune_last_offset != null and current_offset >= self._prune_last_offset.?) {
            self._prune_offset = null;
            return msg;
        }
        if (self._prune_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._prune_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlMessageWire.PRUNE_WIRE) {
                self._prune_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._prune_offset = null;
        return msg;
    }
    pub fn idontwantCount(self: *const ControlMessageReader) usize {
        return self._idontwant_cnt;
    }
    pub fn idontwantNext(self: *ControlMessageReader) ?ControlIDontWantReader {
        if (self._idontwant_offset == null) return null;
        const current_offset = self._idontwant_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ControlIDontWantReader.init(result.value) catch return null;
        if (self._idontwant_last_offset != null and current_offset >= self._idontwant_last_offset.?) {
            self._idontwant_offset = null;
            return msg;
        }
        if (self._idontwant_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._idontwant_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlMessageWire.IDONTWANT_WIRE) {
                self._idontwant_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._idontwant_offset = null;
        return msg;
    }
};
const ControlIHaveWire = struct {
    const TOPIC_IDWIRE: gremlin.ProtoWireNumber = 1;
    const MESSAGE_IDS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ControlIHave = struct {
    // fields
    topic_i_d: ?[]const u8 = null,
    message_i_ds: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ControlIHave) usize {
        var res: usize = 0;
        if (self.topic_i_d) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ControlIHaveWire.TOPIC_IDWIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.message_i_ds) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlIHaveWire.MESSAGE_IDS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ControlIHave, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ControlIHave, target: *gremlin.Writer) void {
        if (self.topic_i_d) |v| {
            if (v.len > 0) {
                target.appendBytes(ControlIHaveWire.TOPIC_IDWIRE, v);
            }
        }
        if (self.message_i_ds) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ControlIHaveWire.MESSAGE_IDS_WIRE, v);
                } else {
                    target.appendBytesTag(ControlIHaveWire.MESSAGE_IDS_WIRE, 0);
                }
            }
        }
    }
};
pub const ControlIHaveReader = struct {
    buf: gremlin.Reader,
    _topic_i_d: ?[]const u8 = null,
    _message_i_ds_offset: ?usize = null,
    _message_i_ds_last_offset: ?usize = null,
    _message_i_ds_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ControlIHaveReader {
        const buf = gremlin.Reader.init(src);
        var res = ControlIHaveReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ControlIHaveWire.TOPIC_IDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._topic_i_d = result.value;
                },
                ControlIHaveWire.MESSAGE_IDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._message_i_ds_offset == null) {
                        res._message_i_ds_offset = offset - result.size;
                    }
                    res._message_i_ds_last_offset = offset;
                    res._message_i_ds_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTopicID(self: *const ControlIHaveReader) []const u8 {
        return self._topic_i_d orelse &[_]u8{};
    }
    pub fn messageIDsCount(self: *const ControlIHaveReader) usize {
        return self._message_i_ds_cnt;
    }
    pub fn messageIDsNext(self: *ControlIHaveReader) ?[]const u8 {
        if (self._message_i_ds_offset == null) return null;
        const current_offset = self._message_i_ds_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._message_i_ds_last_offset != null and current_offset >= self._message_i_ds_last_offset.?) {
            self._message_i_ds_offset = null;
            return result.value;
        }
        if (self._message_i_ds_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._message_i_ds_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlIHaveWire.MESSAGE_IDS_WIRE) {
                self._message_i_ds_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._message_i_ds_offset = null;
        return result.value;
    }
};
const ControlIWantWire = struct {
    const MESSAGE_IDS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ControlIWant = struct {
    // fields
    message_i_ds: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ControlIWant) usize {
        var res: usize = 0;
        if (self.message_i_ds) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlIWantWire.MESSAGE_IDS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ControlIWant, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ControlIWant, target: *gremlin.Writer) void {
        if (self.message_i_ds) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ControlIWantWire.MESSAGE_IDS_WIRE, v);
                } else {
                    target.appendBytesTag(ControlIWantWire.MESSAGE_IDS_WIRE, 0);
                }
            }
        }
    }
};
pub const ControlIWantReader = struct {
    buf: gremlin.Reader,
    _message_i_ds_offset: ?usize = null,
    _message_i_ds_last_offset: ?usize = null,
    _message_i_ds_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ControlIWantReader {
        const buf = gremlin.Reader.init(src);
        var res = ControlIWantReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ControlIWantWire.MESSAGE_IDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._message_i_ds_offset == null) {
                        res._message_i_ds_offset = offset - result.size;
                    }
                    res._message_i_ds_last_offset = offset;
                    res._message_i_ds_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn messageIDsCount(self: *const ControlIWantReader) usize {
        return self._message_i_ds_cnt;
    }
    pub fn messageIDsNext(self: *ControlIWantReader) ?[]const u8 {
        if (self._message_i_ds_offset == null) return null;
        const current_offset = self._message_i_ds_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._message_i_ds_last_offset != null and current_offset >= self._message_i_ds_last_offset.?) {
            self._message_i_ds_offset = null;
            return result.value;
        }
        if (self._message_i_ds_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._message_i_ds_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlIWantWire.MESSAGE_IDS_WIRE) {
                self._message_i_ds_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._message_i_ds_offset = null;
        return result.value;
    }
};
const ControlGraftWire = struct {
    const TOPIC_IDWIRE: gremlin.ProtoWireNumber = 1;
};
pub const ControlGraft = struct {
    // fields
    topic_i_d: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ControlGraft) usize {
        var res: usize = 0;
        if (self.topic_i_d) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ControlGraftWire.TOPIC_IDWIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ControlGraft, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ControlGraft, target: *gremlin.Writer) void {
        if (self.topic_i_d) |v| {
            if (v.len > 0) {
                target.appendBytes(ControlGraftWire.TOPIC_IDWIRE, v);
            }
        }
    }
};
pub const ControlGraftReader = struct {
    buf: gremlin.Reader,
    _topic_i_d: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ControlGraftReader {
        const buf = gremlin.Reader.init(src);
        var res = ControlGraftReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ControlGraftWire.TOPIC_IDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._topic_i_d = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTopicID(self: *const ControlGraftReader) []const u8 {
        return self._topic_i_d orelse &[_]u8{};
    }
};
const ControlPruneWire = struct {
    const TOPIC_IDWIRE: gremlin.ProtoWireNumber = 1;
    const PEERS_WIRE: gremlin.ProtoWireNumber = 2;
    const BACKOFF_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ControlPrune = struct {
    // fields
    topic_i_d: ?[]const u8 = null,
    peers: ?[]const ?PeerInfo = null,
    backoff: u64 = 0,
    pub fn calcProtobufSize(self: *const ControlPrune) usize {
        var res: usize = 0;
        if (self.topic_i_d) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ControlPruneWire.TOPIC_IDWIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.peers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlPruneWire.PEERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.backoff != 0) {
            res += gremlin.sizes.sizeWireNumber(ControlPruneWire.BACKOFF_WIRE) + gremlin.sizes.sizeU64(self.backoff);
        }
        return res;
    }
    pub fn encode(self: *const ControlPrune, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ControlPrune, target: *gremlin.Writer) void {
        if (self.topic_i_d) |v| {
            if (v.len > 0) {
                target.appendBytes(ControlPruneWire.TOPIC_IDWIRE, v);
            }
        }
        if (self.peers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ControlPruneWire.PEERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ControlPruneWire.PEERS_WIRE, 0);
                }
            }
        }
        if (self.backoff != 0) {
            target.appendUint64(ControlPruneWire.BACKOFF_WIRE, self.backoff);
        }
    }
};
pub const ControlPruneReader = struct {
    buf: gremlin.Reader,
    _topic_i_d: ?[]const u8 = null,
    _peers_offset: ?usize = null,
    _peers_last_offset: ?usize = null,
    _peers_cnt: usize = 0,
    _backoff: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ControlPruneReader {
        const buf = gremlin.Reader.init(src);
        var res = ControlPruneReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ControlPruneWire.TOPIC_IDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._topic_i_d = result.value;
                },
                ControlPruneWire.PEERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._peers_offset == null) {
                        res._peers_offset = offset - result.size;
                    }
                    res._peers_last_offset = offset;
                    res._peers_cnt += 1;
                },
                ControlPruneWire.BACKOFF_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._backoff = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTopicID(self: *const ControlPruneReader) []const u8 {
        return self._topic_i_d orelse &[_]u8{};
    }
    pub fn peersCount(self: *const ControlPruneReader) usize {
        return self._peers_cnt;
    }
    pub fn peersNext(self: *ControlPruneReader) ?PeerInfoReader {
        if (self._peers_offset == null) return null;
        const current_offset = self._peers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = PeerInfoReader.init(result.value) catch return null;
        if (self._peers_last_offset != null and current_offset >= self._peers_last_offset.?) {
            self._peers_offset = null;
            return msg;
        }
        if (self._peers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._peers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlPruneWire.PEERS_WIRE) {
                self._peers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._peers_offset = null;
        return msg;
    }
    pub inline fn getBackoff(self: *const ControlPruneReader) u64 {
        return self._backoff;
    }
};
const ControlIDontWantWire = struct {
    const MESSAGE_IDS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ControlIDontWant = struct {
    // fields
    message_i_ds: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ControlIDontWant) usize {
        var res: usize = 0;
        if (self.message_i_ds) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ControlIDontWantWire.MESSAGE_IDS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ControlIDontWant, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ControlIDontWant, target: *gremlin.Writer) void {
        if (self.message_i_ds) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ControlIDontWantWire.MESSAGE_IDS_WIRE, v);
                } else {
                    target.appendBytesTag(ControlIDontWantWire.MESSAGE_IDS_WIRE, 0);
                }
            }
        }
    }
};
pub const ControlIDontWantReader = struct {
    buf: gremlin.Reader,
    _message_i_ds_offset: ?usize = null,
    _message_i_ds_last_offset: ?usize = null,
    _message_i_ds_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ControlIDontWantReader {
        const buf = gremlin.Reader.init(src);
        var res = ControlIDontWantReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ControlIDontWantWire.MESSAGE_IDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._message_i_ds_offset == null) {
                        res._message_i_ds_offset = offset - result.size;
                    }
                    res._message_i_ds_last_offset = offset;
                    res._message_i_ds_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn messageIDsCount(self: *const ControlIDontWantReader) usize {
        return self._message_i_ds_cnt;
    }
    pub fn messageIDsNext(self: *ControlIDontWantReader) ?[]const u8 {
        if (self._message_i_ds_offset == null) return null;
        const current_offset = self._message_i_ds_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._message_i_ds_last_offset != null and current_offset >= self._message_i_ds_last_offset.?) {
            self._message_i_ds_offset = null;
            return result.value;
        }
        if (self._message_i_ds_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._message_i_ds_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ControlIDontWantWire.MESSAGE_IDS_WIRE) {
                self._message_i_ds_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._message_i_ds_offset = null;
        return result.value;
    }
};
const PeerInfoWire = struct {
    const PEER_IDWIRE: gremlin.ProtoWireNumber = 1;
    const SIGNED_PEER_RECORD_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const PeerInfo = struct {
    // fields
    peer_i_d: ?[]const u8 = null,
    signed_peer_record: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const PeerInfo) usize {
        var res: usize = 0;
        if (self.peer_i_d) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(PeerInfoWire.PEER_IDWIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.signed_peer_record) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(PeerInfoWire.SIGNED_PEER_RECORD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const PeerInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PeerInfo, target: *gremlin.Writer) void {
        if (self.peer_i_d) |v| {
            if (v.len > 0) {
                target.appendBytes(PeerInfoWire.PEER_IDWIRE, v);
            }
        }
        if (self.signed_peer_record) |v| {
            if (v.len > 0) {
                target.appendBytes(PeerInfoWire.SIGNED_PEER_RECORD_WIRE, v);
            }
        }
    }
};
pub const PeerInfoReader = struct {
    buf: gremlin.Reader,
    _peer_i_d: ?[]const u8 = null,
    _signed_peer_record: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!PeerInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = PeerInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PeerInfoWire.PEER_IDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._peer_i_d = result.value;
                },
                PeerInfoWire.SIGNED_PEER_RECORD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._signed_peer_record = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPeerID(self: *const PeerInfoReader) []const u8 {
        return self._peer_i_d orelse &[_]u8{};
    }
    pub inline fn getSignedPeerRecord(self: *const PeerInfoReader) []const u8 {
        return self._signed_peer_record orelse &[_]u8{};
    }
};
const TopicDescriptorWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const AUTH_WIRE: gremlin.ProtoWireNumber = 2;
    const ENC_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TopicDescriptor = struct {
    // nested structs
    const AuthOptsWire = struct {
        const MODE_WIRE: gremlin.ProtoWireNumber = 1;
        const KEYS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const AuthOpts = struct {
        // nested enums
        pub const AuthMode = enum(i32) {
            NONE = 0,
            KEY = 1,
            WOT = 2,
        };
        // fields
        mode: TopicDescriptor.AuthOpts.AuthMode = @enumFromInt(0),
        keys: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TopicDescriptor.AuthOpts) usize {
            var res: usize = 0;
            if (@intFromEnum(self.mode) != 0) {
                res += gremlin.sizes.sizeWireNumber(TopicDescriptor.AuthOptsWire.MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.mode));
            }
            if (self.keys) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TopicDescriptor.AuthOptsWire.KEYS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const TopicDescriptor.AuthOpts, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TopicDescriptor.AuthOpts, target: *gremlin.Writer) void {
            if (@intFromEnum(self.mode) != 0) {
                target.appendInt32(TopicDescriptor.AuthOptsWire.MODE_WIRE, @intFromEnum(self.mode));
            }
            if (self.keys) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(TopicDescriptor.AuthOptsWire.KEYS_WIRE, v);
                    } else {
                        target.appendBytesTag(TopicDescriptor.AuthOptsWire.KEYS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const AuthOptsReader = struct {
        buf: gremlin.Reader,
        _mode: TopicDescriptor.AuthOpts.AuthMode = @enumFromInt(0),
        _keys_offset: ?usize = null,
        _keys_last_offset: ?usize = null,
        _keys_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!TopicDescriptor.AuthOptsReader {
            const buf = gremlin.Reader.init(src);
            var res = TopicDescriptor.AuthOptsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TopicDescriptor.AuthOptsWire.MODE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._mode = @enumFromInt(result.value);
                    },
                    TopicDescriptor.AuthOptsWire.KEYS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._keys_offset == null) {
                            res._keys_offset = offset - result.size;
                        }
                        res._keys_last_offset = offset;
                        res._keys_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMode(self: *const TopicDescriptor.AuthOptsReader) TopicDescriptor.AuthOpts.AuthMode {
            return self._mode;
        }
        pub fn keysCount(self: *const TopicDescriptor.AuthOptsReader) usize {
            return self._keys_cnt;
        }
        pub fn keysNext(self: *TopicDescriptor.AuthOptsReader) ?[]const u8 {
            if (self._keys_offset == null) return null;
            const current_offset = self._keys_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._keys_last_offset != null and current_offset >= self._keys_last_offset.?) {
                self._keys_offset = null;
                return result.value;
            }
            if (self._keys_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._keys_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TopicDescriptor.AuthOptsWire.KEYS_WIRE) {
                    self._keys_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._keys_offset = null;
            return result.value;
        }
    };
    const EncOptsWire = struct {
        const MODE_WIRE: gremlin.ProtoWireNumber = 1;
        const KEY_HASHES_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const EncOpts = struct {
        // nested enums
        pub const EncMode = enum(i32) {
            NONE = 0,
            SHAREDKEY = 1,
            WOT = 2,
        };
        // fields
        mode: TopicDescriptor.EncOpts.EncMode = @enumFromInt(0),
        key_hashes: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TopicDescriptor.EncOpts) usize {
            var res: usize = 0;
            if (@intFromEnum(self.mode) != 0) {
                res += gremlin.sizes.sizeWireNumber(TopicDescriptor.EncOptsWire.MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.mode));
            }
            if (self.key_hashes) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TopicDescriptor.EncOptsWire.KEY_HASHES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const TopicDescriptor.EncOpts, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TopicDescriptor.EncOpts, target: *gremlin.Writer) void {
            if (@intFromEnum(self.mode) != 0) {
                target.appendInt32(TopicDescriptor.EncOptsWire.MODE_WIRE, @intFromEnum(self.mode));
            }
            if (self.key_hashes) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(TopicDescriptor.EncOptsWire.KEY_HASHES_WIRE, v);
                    } else {
                        target.appendBytesTag(TopicDescriptor.EncOptsWire.KEY_HASHES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const EncOptsReader = struct {
        buf: gremlin.Reader,
        _mode: TopicDescriptor.EncOpts.EncMode = @enumFromInt(0),
        _key_hashes_offset: ?usize = null,
        _key_hashes_last_offset: ?usize = null,
        _key_hashes_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!TopicDescriptor.EncOptsReader {
            const buf = gremlin.Reader.init(src);
            var res = TopicDescriptor.EncOptsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TopicDescriptor.EncOptsWire.MODE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._mode = @enumFromInt(result.value);
                    },
                    TopicDescriptor.EncOptsWire.KEY_HASHES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._key_hashes_offset == null) {
                            res._key_hashes_offset = offset - result.size;
                        }
                        res._key_hashes_last_offset = offset;
                        res._key_hashes_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMode(self: *const TopicDescriptor.EncOptsReader) TopicDescriptor.EncOpts.EncMode {
            return self._mode;
        }
        pub fn keyHashesCount(self: *const TopicDescriptor.EncOptsReader) usize {
            return self._key_hashes_cnt;
        }
        pub fn keyHashesNext(self: *TopicDescriptor.EncOptsReader) ?[]const u8 {
            if (self._key_hashes_offset == null) return null;
            const current_offset = self._key_hashes_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._key_hashes_last_offset != null and current_offset >= self._key_hashes_last_offset.?) {
                self._key_hashes_offset = null;
                return result.value;
            }
            if (self._key_hashes_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._key_hashes_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TopicDescriptor.EncOptsWire.KEY_HASHES_WIRE) {
                    self._key_hashes_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._key_hashes_offset = null;
            return result.value;
        }
    };
    // fields
    name: ?[]const u8 = null,
    auth: ?TopicDescriptor.AuthOpts = null,
    enc: ?TopicDescriptor.EncOpts = null,
    pub fn calcProtobufSize(self: *const TopicDescriptor) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TopicDescriptorWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.auth) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TopicDescriptorWire.AUTH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.enc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TopicDescriptorWire.ENC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TopicDescriptor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TopicDescriptor, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(TopicDescriptorWire.NAME_WIRE, v);
            }
        }
        if (self.auth) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TopicDescriptorWire.AUTH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.enc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TopicDescriptorWire.ENC_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TopicDescriptorReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _auth_buf: ?[]const u8 = null,
    _enc_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TopicDescriptorReader {
        const buf = gremlin.Reader.init(src);
        var res = TopicDescriptorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TopicDescriptorWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                TopicDescriptorWire.AUTH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._auth_buf = result.value;
                },
                TopicDescriptorWire.ENC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._enc_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const TopicDescriptorReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn getAuth(self: *const TopicDescriptorReader) gremlin.Error!TopicDescriptor.AuthOptsReader {
        if (self._auth_buf) |buf| {
            return try TopicDescriptor.AuthOptsReader.init(buf);
        }
        return try TopicDescriptor.AuthOptsReader.init(&[_]u8{});
    }
    pub fn getEnc(self: *const TopicDescriptorReader) gremlin.Error!TopicDescriptor.EncOptsReader {
        if (self._enc_buf) |buf| {
            return try TopicDescriptor.EncOptsReader.init(buf);
        }
        return try TopicDescriptor.EncOptsReader.init(&[_]u8{});
    }
};
